// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package kotlinconf.elasticleaderboard

import aws.smithy.kotlin.runtime.auth.AuthSchemeId
import aws.smithy.kotlin.runtime.client.SdkClientOption
import aws.smithy.kotlin.runtime.collections.putIfAbsent
import aws.smithy.kotlin.runtime.collections.putIfAbsentNotNull
import aws.smithy.kotlin.runtime.http.SdkHttpClient
import aws.smithy.kotlin.runtime.http.auth.AnonymousAuthScheme
import aws.smithy.kotlin.runtime.http.auth.AuthScheme
import aws.smithy.kotlin.runtime.http.operation.OperationAuthConfig
import aws.smithy.kotlin.runtime.http.operation.OperationMetrics
import aws.smithy.kotlin.runtime.http.operation.SdkHttpOperation
import aws.smithy.kotlin.runtime.http.operation.context
import aws.smithy.kotlin.runtime.http.operation.roundTrip
import aws.smithy.kotlin.runtime.http.operation.telemetry
import aws.smithy.kotlin.runtime.io.SdkManagedGroup
import aws.smithy.kotlin.runtime.io.addIfManaged
import aws.smithy.kotlin.runtime.operation.ExecutionContext
import kotlinconf.elasticleaderboard.auth.ElasticLeaderboardAuthSchemeProviderAdapter
import kotlinconf.elasticleaderboard.auth.ElasticLeaderboardIdentityProviderConfigAdapter
import kotlinconf.elasticleaderboard.endpoints.internal.EndpointResolverAdapter
import kotlinconf.elasticleaderboard.model.*
import kotlinconf.elasticleaderboard.serde.*

internal class DefaultElasticLeaderboardClient(override val config: ElasticLeaderboardClient.Config) : ElasticLeaderboardClient {
    private val managedResources = SdkManagedGroup()
    private val client = SdkHttpClient(config.httpClient)
    private val identityProviderConfig = ElasticLeaderboardIdentityProviderConfigAdapter(config)
    private val configuredAuthSchemes = with(config.authSchemes.associateBy(AuthScheme::schemeId).toMutableMap()){
        getOrPut(AuthSchemeId.Anonymous){
            AnonymousAuthScheme
        }
        toMap()
    }
    private val authSchemeAdapter = ElasticLeaderboardAuthSchemeProviderAdapter(config)
    private val telemetryScope = "kotlinconf.elasticleaderboard"
    private val opMetrics = OperationMetrics(telemetryScope, config.telemetryProvider)

    init {
        managedResources.addIfManaged(config.httpClient)
    }

    /**
     * Create a new leaderboard
     */
    override suspend fun createLeaderboard(input: CreateLeaderboardRequest): CreateLeaderboardResponse {
        val op = SdkHttpOperation.build<CreateLeaderboardRequest, CreateLeaderboardResponse> {
            serializeWith = CreateLeaderboardOperationSerializer()
            deserializeWith = CreateLeaderboardOperationDeserializer()
            operationName = "CreateLeaderboard"
            serviceName = ServiceId
            telemetry {
                provider = config.telemetryProvider
                scope = telemetryScope
                metrics = opMetrics
            }
            execution.auth = OperationAuthConfig(authSchemeAdapter, configuredAuthSchemes, identityProviderConfig)
            execution.endpointResolver = EndpointResolverAdapter(config)
            execution.retryStrategy = config.retryStrategy
            execution.retryPolicy = config.retryPolicy
        }
        mergeServiceDefaults(op.context)
        op.interceptors.addAll(config.interceptors)
        return op.roundTrip(client, input)
    }

    /**
     * Delete a leaderboard
     */
    override suspend fun deleteLeaderboard(input: DeleteLeaderboardRequest): DeleteLeaderboardResponse {
        val op = SdkHttpOperation.build<DeleteLeaderboardRequest, DeleteLeaderboardResponse> {
            serializeWith = DeleteLeaderboardOperationSerializer()
            deserializeWith = DeleteLeaderboardOperationDeserializer()
            operationName = "DeleteLeaderboard"
            serviceName = ServiceId
            telemetry {
                provider = config.telemetryProvider
                scope = telemetryScope
                metrics = opMetrics
            }
            execution.auth = OperationAuthConfig(authSchemeAdapter, configuredAuthSchemes, identityProviderConfig)
            execution.endpointResolver = EndpointResolverAdapter(config)
            execution.retryStrategy = config.retryStrategy
            execution.retryPolicy = config.retryPolicy
        }
        mergeServiceDefaults(op.context)
        op.interceptors.addAll(config.interceptors)
        return op.roundTrip(client, input)
    }

    /**
     * Get detailed information about a specific leaderboard including it's high scores
     */
    override suspend fun getLeaderboard(input: GetLeaderboardRequest): GetLeaderboardResponse {
        val op = SdkHttpOperation.build<GetLeaderboardRequest, GetLeaderboardResponse> {
            serializeWith = GetLeaderboardOperationSerializer()
            deserializeWith = GetLeaderboardOperationDeserializer()
            operationName = "GetLeaderboard"
            serviceName = ServiceId
            telemetry {
                provider = config.telemetryProvider
                scope = telemetryScope
                metrics = opMetrics
            }
            execution.auth = OperationAuthConfig(authSchemeAdapter, configuredAuthSchemes, identityProviderConfig)
            execution.endpointResolver = EndpointResolverAdapter(config)
            execution.retryStrategy = config.retryStrategy
            execution.retryPolicy = config.retryPolicy
        }
        mergeServiceDefaults(op.context)
        op.interceptors.addAll(config.interceptors)
        return op.roundTrip(client, input)
    }

    /**
     * List the available leaderboards
     */
    override suspend fun listLeaderboards(input: ListLeaderboardsRequest): ListLeaderboardsResponse {
        val op = SdkHttpOperation.build<ListLeaderboardsRequest, ListLeaderboardsResponse> {
            serializeWith = ListLeaderboardsOperationSerializer()
            deserializeWith = ListLeaderboardsOperationDeserializer()
            operationName = "ListLeaderboards"
            serviceName = ServiceId
            telemetry {
                provider = config.telemetryProvider
                scope = telemetryScope
                metrics = opMetrics
            }
            execution.auth = OperationAuthConfig(authSchemeAdapter, configuredAuthSchemes, identityProviderConfig)
            execution.endpointResolver = EndpointResolverAdapter(config)
            execution.retryStrategy = config.retryStrategy
            execution.retryPolicy = config.retryPolicy
        }
        mergeServiceDefaults(op.context)
        op.interceptors.addAll(config.interceptors)
        return op.roundTrip(client, input)
    }

    /**
     * Log a new high score for a user
     */
    override suspend fun submitScoreEvent(input: SubmitScoreEventRequest): SubmitScoreEventResponse {
        val op = SdkHttpOperation.build<SubmitScoreEventRequest, SubmitScoreEventResponse> {
            serializeWith = SubmitScoreEventOperationSerializer()
            deserializeWith = SubmitScoreEventOperationDeserializer()
            operationName = "SubmitScoreEvent"
            serviceName = ServiceId
            telemetry {
                provider = config.telemetryProvider
                scope = telemetryScope
                metrics = opMetrics
            }
            execution.auth = OperationAuthConfig(authSchemeAdapter, configuredAuthSchemes, identityProviderConfig)
            execution.endpointResolver = EndpointResolverAdapter(config)
            execution.retryStrategy = config.retryStrategy
            execution.retryPolicy = config.retryPolicy
        }
        mergeServiceDefaults(op.context)
        op.interceptors.addAll(config.interceptors)
        return op.roundTrip(client, input)
    }

    /**
     * Update a leaderboard's configuration
     */
    override suspend fun updateLeaderboard(input: UpdateLeaderboardRequest): UpdateLeaderboardResponse {
        val op = SdkHttpOperation.build<UpdateLeaderboardRequest, UpdateLeaderboardResponse> {
            serializeWith = UpdateLeaderboardOperationSerializer()
            deserializeWith = UpdateLeaderboardOperationDeserializer()
            operationName = "UpdateLeaderboard"
            serviceName = ServiceId
            telemetry {
                provider = config.telemetryProvider
                scope = telemetryScope
                metrics = opMetrics
            }
            execution.auth = OperationAuthConfig(authSchemeAdapter, configuredAuthSchemes, identityProviderConfig)
            execution.endpointResolver = EndpointResolverAdapter(config)
            execution.retryStrategy = config.retryStrategy
            execution.retryPolicy = config.retryPolicy
        }
        mergeServiceDefaults(op.context)
        op.interceptors.addAll(config.interceptors)
        return op.roundTrip(client, input)
    }

    override fun close() {
        managedResources.unshareAll()
    }

    /**
     * merge the defaults configured for the service into the execution context before firing off a request
     */
    private fun mergeServiceDefaults(ctx: ExecutionContext) {
        ctx.putIfAbsent(SdkClientOption.ClientName, config.clientName)
        ctx.putIfAbsent(SdkClientOption.LogMode, config.logMode)
        ctx.putIfAbsentNotNull(SdkClientOption.IdempotencyTokenProvider, config.idempotencyTokenProvider)
    }

}
