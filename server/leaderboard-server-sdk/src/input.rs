// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct SubmitScoreEventInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub id: crate::model::LeaderboardId,
    #[allow(missing_docs)] // documentation missing in model
    pub score_event: crate::model::ScoreEvent,
}
impl  SubmitScoreEventInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn id(&self) -> & crate::model::LeaderboardId {
        &self.id
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn score_event(&self) -> & crate::model::ScoreEvent {
        &self.score_event
    }
}
impl  SubmitScoreEventInput  {
    /// Creates a new builder-style object to manufacture [`SubmitScoreEventInput`](crate::input::SubmitScoreEventInput).
    pub fn builder() -> crate::input::submit_score_event_input::Builder  {
        crate::input::submit_score_event_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::SubmitScoreEventInput {
                type Unconstrained = crate::input::submit_score_event_input::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct DeleteLeaderboardInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub id: crate::model::LeaderboardId,
}
impl  DeleteLeaderboardInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn id(&self) -> & crate::model::LeaderboardId {
        &self.id
    }
}
impl  DeleteLeaderboardInput  {
    /// Creates a new builder-style object to manufacture [`DeleteLeaderboardInput`](crate::input::DeleteLeaderboardInput).
    pub fn builder() -> crate::input::delete_leaderboard_input::Builder  {
        crate::input::delete_leaderboard_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::DeleteLeaderboardInput {
                type Unconstrained = crate::input::delete_leaderboard_input::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct UpdateLeaderboardInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub id: crate::model::LeaderboardId,
    #[allow(missing_docs)] // documentation missing in model
    pub name: ::std::option::Option<::std::string::String>,
}
impl  UpdateLeaderboardInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn id(&self) -> & crate::model::LeaderboardId {
        &self.id
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> ::std::option::Option<& str> {
        self.name.as_deref()
    }
}
impl  UpdateLeaderboardInput  {
    /// Creates a new builder-style object to manufacture [`UpdateLeaderboardInput`](crate::input::UpdateLeaderboardInput).
    pub fn builder() -> crate::input::update_leaderboard_input::Builder  {
        crate::input::update_leaderboard_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::UpdateLeaderboardInput {
                type Unconstrained = crate::input::update_leaderboard_input::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct GetLeaderboardInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub id: crate::model::LeaderboardId,
}
impl  GetLeaderboardInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn id(&self) -> & crate::model::LeaderboardId {
        &self.id
    }
}
impl  GetLeaderboardInput  {
    /// Creates a new builder-style object to manufacture [`GetLeaderboardInput`](crate::input::GetLeaderboardInput).
    pub fn builder() -> crate::input::get_leaderboard_input::Builder  {
        crate::input::get_leaderboard_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::GetLeaderboardInput {
                type Unconstrained = crate::input::get_leaderboard_input::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct CreateLeaderboardInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub max_entries: crate::model::MaxEntries,
    #[allow(missing_docs)] // documentation missing in model
    pub token: ::std::option::Option<::std::string::String>,
}
impl  CreateLeaderboardInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> & str {
        use std::ops::Deref; self.name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn max_entries(&self) -> & crate::model::MaxEntries {
        &self.max_entries
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn token(&self) -> ::std::option::Option<& str> {
        self.token.as_deref()
    }
}
impl  CreateLeaderboardInput  {
    /// Creates a new builder-style object to manufacture [`CreateLeaderboardInput`](crate::input::CreateLeaderboardInput).
    pub fn builder() -> crate::input::create_leaderboard_input::Builder  {
        crate::input::create_leaderboard_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::CreateLeaderboardInput {
                type Unconstrained = crate::input::create_leaderboard_input::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct ListLeaderboardsInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub next_token: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub max_results: ::std::option::Option<i32>,
}
impl  ListLeaderboardsInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn next_token(&self) -> ::std::option::Option<& str> {
        self.next_token.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn max_results(&self) -> ::std::option::Option<i32> {
        self.max_results
    }
}
impl  ListLeaderboardsInput  {
    /// Creates a new builder-style object to manufacture [`ListLeaderboardsInput`](crate::input::ListLeaderboardsInput).
    pub fn builder() -> crate::input::list_leaderboards_input::Builder  {
        crate::input::list_leaderboards_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::ListLeaderboardsInput {
                type Unconstrained = crate::input::list_leaderboards_input::Builder;
            }
/// See [`SubmitScoreEventInput`](crate::input::SubmitScoreEventInput).
/// 
pub mod submit_score_event_input {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    
                #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `id` was not provided but it is required when building `SubmitScoreEventInput`.
        MissingId,
        /// Constraint violation occurred building member `id` when building `SubmitScoreEventInput`.
        #[doc(hidden)]
        Id(crate::model::leaderboard_id::ConstraintViolation),
        /// `score_event` was not provided but it is required when building `SubmitScoreEventInput`.
        MissingScoreEvent,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingId => write!(f, "`id` was not provided but it is required when building `SubmitScoreEventInput`"),
                ConstraintViolation::Id(_) => write!(f, "constraint violation occurred building member `id` when building `SubmitScoreEventInput`"),
                ConstraintViolation::MissingScoreEvent => write!(f, "`score_event` was not provided but it is required when building `SubmitScoreEventInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        match self {
        ConstraintViolation::MissingId => crate::model::ValidationExceptionField {
                                        message: format!("Value at '{}/id' failed to satisfy constraint: Member must not be null", path),
                                        path: path + "/id",
                                    },
        ConstraintViolation::Id(inner) => inner.as_validation_exception_field(path + "/id"),
        ConstraintViolation::MissingScoreEvent => crate::model::ValidationExceptionField {
                                        message: format!("Value at '{}/scoreEvent' failed to satisfy constraint: Member must not be null", path),
                                        path: path + "/scoreEvent",
                                    },
    }
                    }
                }
    impl ::std::convert::From<ConstraintViolation> for ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection {
                        fn from(constraint_violation: ConstraintViolation) -> Self {
                            let first_validation_exception_field = constraint_violation.as_validation_exception_field("".to_owned());
                            let validation_exception = crate::error::ValidationException {
                                message: format!("1 validation error detected. {}", &first_validation_exception_field.message),
                                field_list: Some(vec![first_validation_exception_field]),
                            };
                            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
                        }
                    }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::input::SubmitScoreEventInput> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::input::SubmitScoreEventInput {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`SubmitScoreEventInput`](crate::input::SubmitScoreEventInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::LeaderboardId>>,
        pub(crate) score_event: ::std::option::Option<crate::model::ScoreEvent>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn id(mut self, input: crate::model::LeaderboardId) -> Self {
            self.id =
                Some(
                    crate::constrained::MaybeConstrained::Constrained(input)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_id(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::LeaderboardId>>) -> Self {
            self.id = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn score_event(mut self, input: crate::model::ScoreEvent) -> Self {
            self.score_event =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_score_event(mut self, input: impl ::std::convert::Into<crate::model::ScoreEvent>) -> Self {
            self.score_event = Some(input.into());
                            self
        }
        /// Consumes the builder and constructs a [`SubmitScoreEventInput`](crate::input::SubmitScoreEventInput).
        /// 
        /// The builder fails to construct a [`SubmitScoreEventInput`](crate::input::SubmitScoreEventInput) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::SubmitScoreEventInput , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::input::SubmitScoreEventInput , ConstraintViolation> {
            Ok(
                crate::input::SubmitScoreEventInput {
                    id: self.id
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::Id)
                                    )
                                    .transpose()?
                        .ok_or(ConstraintViolation::MissingId)?
                    ,
                    score_event: self.score_event
                        .ok_or(ConstraintViolation::MissingScoreEvent)?
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`DeleteLeaderboardInput`](crate::input::DeleteLeaderboardInput).
/// 
pub mod delete_leaderboard_input {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    
                #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `id` was not provided but it is required when building `DeleteLeaderboardInput`.
        MissingId,
        /// Constraint violation occurred building member `id` when building `DeleteLeaderboardInput`.
        #[doc(hidden)]
        Id(crate::model::leaderboard_id::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingId => write!(f, "`id` was not provided but it is required when building `DeleteLeaderboardInput`"),
                ConstraintViolation::Id(_) => write!(f, "constraint violation occurred building member `id` when building `DeleteLeaderboardInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        match self {
        ConstraintViolation::MissingId => crate::model::ValidationExceptionField {
                                        message: format!("Value at '{}/id' failed to satisfy constraint: Member must not be null", path),
                                        path: path + "/id",
                                    },
        ConstraintViolation::Id(inner) => inner.as_validation_exception_field(path + "/id"),
    }
                    }
                }
    impl ::std::convert::From<ConstraintViolation> for ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection {
                        fn from(constraint_violation: ConstraintViolation) -> Self {
                            let first_validation_exception_field = constraint_violation.as_validation_exception_field("".to_owned());
                            let validation_exception = crate::error::ValidationException {
                                message: format!("1 validation error detected. {}", &first_validation_exception_field.message),
                                field_list: Some(vec![first_validation_exception_field]),
                            };
                            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
                        }
                    }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::input::DeleteLeaderboardInput> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::input::DeleteLeaderboardInput {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`DeleteLeaderboardInput`](crate::input::DeleteLeaderboardInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::LeaderboardId>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn id(mut self, input: crate::model::LeaderboardId) -> Self {
            self.id =
                Some(
                    crate::constrained::MaybeConstrained::Constrained(input)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_id(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::LeaderboardId>>) -> Self {
            self.id = Some(input.into());
                            self
        }
        /// Consumes the builder and constructs a [`DeleteLeaderboardInput`](crate::input::DeleteLeaderboardInput).
        /// 
        /// The builder fails to construct a [`DeleteLeaderboardInput`](crate::input::DeleteLeaderboardInput) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::DeleteLeaderboardInput , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::input::DeleteLeaderboardInput , ConstraintViolation> {
            Ok(
                crate::input::DeleteLeaderboardInput {
                    id: self.id
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::Id)
                                    )
                                    .transpose()?
                        .ok_or(ConstraintViolation::MissingId)?
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`UpdateLeaderboardInput`](crate::input::UpdateLeaderboardInput).
/// 
pub mod update_leaderboard_input {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    
                #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `id` was not provided but it is required when building `UpdateLeaderboardInput`.
        MissingId,
        /// Constraint violation occurred building member `id` when building `UpdateLeaderboardInput`.
        #[doc(hidden)]
        Id(crate::model::leaderboard_id::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingId => write!(f, "`id` was not provided but it is required when building `UpdateLeaderboardInput`"),
                ConstraintViolation::Id(_) => write!(f, "constraint violation occurred building member `id` when building `UpdateLeaderboardInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        match self {
        ConstraintViolation::MissingId => crate::model::ValidationExceptionField {
                                        message: format!("Value at '{}/id' failed to satisfy constraint: Member must not be null", path),
                                        path: path + "/id",
                                    },
        ConstraintViolation::Id(inner) => inner.as_validation_exception_field(path + "/id"),
    }
                    }
                }
    impl ::std::convert::From<ConstraintViolation> for ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection {
                        fn from(constraint_violation: ConstraintViolation) -> Self {
                            let first_validation_exception_field = constraint_violation.as_validation_exception_field("".to_owned());
                            let validation_exception = crate::error::ValidationException {
                                message: format!("1 validation error detected. {}", &first_validation_exception_field.message),
                                field_list: Some(vec![first_validation_exception_field]),
                            };
                            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
                        }
                    }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::input::UpdateLeaderboardInput> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::input::UpdateLeaderboardInput {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`UpdateLeaderboardInput`](crate::input::UpdateLeaderboardInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::LeaderboardId>>,
        pub(crate) name: ::std::option::Option<::std::string::String>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn id(mut self, input: crate::model::LeaderboardId) -> Self {
            self.id =
                Some(
                    crate::constrained::MaybeConstrained::Constrained(input)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_id(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::LeaderboardId>>) -> Self {
            self.id = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.name =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_name(mut self, input: Option<impl ::std::convert::Into<::std::string::String>>) -> Self {
            self.name = input.map(|v| v.into());
                            self
        }
        /// Consumes the builder and constructs a [`UpdateLeaderboardInput`](crate::input::UpdateLeaderboardInput).
        /// 
        /// The builder fails to construct a [`UpdateLeaderboardInput`](crate::input::UpdateLeaderboardInput) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::UpdateLeaderboardInput , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::input::UpdateLeaderboardInput , ConstraintViolation> {
            Ok(
                crate::input::UpdateLeaderboardInput {
                    id: self.id
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::Id)
                                    )
                                    .transpose()?
                        .ok_or(ConstraintViolation::MissingId)?
                    ,
                    name: self.name
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`GetLeaderboardInput`](crate::input::GetLeaderboardInput).
/// 
pub mod get_leaderboard_input {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    
                #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `id` was not provided but it is required when building `GetLeaderboardInput`.
        MissingId,
        /// Constraint violation occurred building member `id` when building `GetLeaderboardInput`.
        #[doc(hidden)]
        Id(crate::model::leaderboard_id::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingId => write!(f, "`id` was not provided but it is required when building `GetLeaderboardInput`"),
                ConstraintViolation::Id(_) => write!(f, "constraint violation occurred building member `id` when building `GetLeaderboardInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        match self {
        ConstraintViolation::MissingId => crate::model::ValidationExceptionField {
                                        message: format!("Value at '{}/id' failed to satisfy constraint: Member must not be null", path),
                                        path: path + "/id",
                                    },
        ConstraintViolation::Id(inner) => inner.as_validation_exception_field(path + "/id"),
    }
                    }
                }
    impl ::std::convert::From<ConstraintViolation> for ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection {
                        fn from(constraint_violation: ConstraintViolation) -> Self {
                            let first_validation_exception_field = constraint_violation.as_validation_exception_field("".to_owned());
                            let validation_exception = crate::error::ValidationException {
                                message: format!("1 validation error detected. {}", &first_validation_exception_field.message),
                                field_list: Some(vec![first_validation_exception_field]),
                            };
                            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
                        }
                    }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::input::GetLeaderboardInput> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::input::GetLeaderboardInput {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`GetLeaderboardInput`](crate::input::GetLeaderboardInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::LeaderboardId>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn id(mut self, input: crate::model::LeaderboardId) -> Self {
            self.id =
                Some(
                    crate::constrained::MaybeConstrained::Constrained(input)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_id(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::LeaderboardId>>) -> Self {
            self.id = Some(input.into());
                            self
        }
        /// Consumes the builder and constructs a [`GetLeaderboardInput`](crate::input::GetLeaderboardInput).
        /// 
        /// The builder fails to construct a [`GetLeaderboardInput`](crate::input::GetLeaderboardInput) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::GetLeaderboardInput , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::input::GetLeaderboardInput , ConstraintViolation> {
            Ok(
                crate::input::GetLeaderboardInput {
                    id: self.id
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::Id)
                                    )
                                    .transpose()?
                        .ok_or(ConstraintViolation::MissingId)?
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`CreateLeaderboardInput`](crate::input::CreateLeaderboardInput).
/// 
pub mod create_leaderboard_input {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    
                #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `name` was not provided but it is required when building `CreateLeaderboardInput`.
        MissingName,
        /// Constraint violation occurred building member `max_entries` when building `CreateLeaderboardInput`.
        #[doc(hidden)]
        MaxEntries(crate::model::max_entries::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingName => write!(f, "`name` was not provided but it is required when building `CreateLeaderboardInput`"),
                ConstraintViolation::MaxEntries(_) => write!(f, "constraint violation occurred building member `max_entries` when building `CreateLeaderboardInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        match self {
        ConstraintViolation::MissingName => crate::model::ValidationExceptionField {
                                        message: format!("Value at '{}/name' failed to satisfy constraint: Member must not be null", path),
                                        path: path + "/name",
                                    },
        ConstraintViolation::MaxEntries(inner) => inner.as_validation_exception_field(path + "/maxEntries"),
    }
                    }
                }
    impl ::std::convert::From<ConstraintViolation> for ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection {
                        fn from(constraint_violation: ConstraintViolation) -> Self {
                            let first_validation_exception_field = constraint_violation.as_validation_exception_field("".to_owned());
                            let validation_exception = crate::error::ValidationException {
                                message: format!("1 validation error detected. {}", &first_validation_exception_field.message),
                                field_list: Some(vec![first_validation_exception_field]),
                            };
                            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
                        }
                    }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::input::CreateLeaderboardInput> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::input::CreateLeaderboardInput {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`CreateLeaderboardInput`](crate::input::CreateLeaderboardInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: ::std::option::Option<::std::string::String>,
        pub(crate) max_entries: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::MaxEntries>>,
        pub(crate) token: ::std::option::Option<::std::string::String>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: ::std::string::String) -> Self {
            self.name =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
            self.name = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn max_entries(mut self, input: crate::model::MaxEntries) -> Self {
            self.max_entries =
                Some(
                    crate::constrained::MaybeConstrained::Constrained(input)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_max_entries(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::MaxEntries>>) -> Self {
            self.max_entries = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.token =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_token(mut self, input: Option<impl ::std::convert::Into<::std::string::String>>) -> Self {
            self.token = input.map(|v| v.into());
                            self
        }
        /// Consumes the builder and constructs a [`CreateLeaderboardInput`](crate::input::CreateLeaderboardInput).
        /// 
        /// The builder fails to construct a [`CreateLeaderboardInput`](crate::input::CreateLeaderboardInput) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::CreateLeaderboardInput , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::input::CreateLeaderboardInput , ConstraintViolation> {
            Ok(
                crate::input::CreateLeaderboardInput {
                    name: self.name
                        .ok_or(ConstraintViolation::MissingName)?
                    ,
                    max_entries: self.max_entries
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::MaxEntries)
                                    )
                                    .transpose()?
                        .unwrap_or_else(||
                                        10i32
                                            .try_into()
                                            .expect("this check should have failed at generation time; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                                    )
                    ,
                    token: self.token
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`ListLeaderboardsInput`](crate::input::ListLeaderboardsInput).
/// 
pub mod list_leaderboards_input {
    
    impl ::std::convert::From<Builder > for crate::input::ListLeaderboardsInput  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`ListLeaderboardsInput`](crate::input::ListLeaderboardsInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: ::std::option::Option<::std::string::String>,
        pub(crate) max_results: ::std::option::Option<i32>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.next_token =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_next_token(mut self, input: Option<impl ::std::convert::Into<::std::string::String>>) -> Self {
            self.next_token = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn max_results(mut self, input: ::std::option::Option<i32>) -> Self {
            self.max_results =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_max_results(mut self, input: Option<impl ::std::convert::Into<i32>>) -> Self {
            self.max_results = input.map(|v| v.into());
                            self
        }
        /// Consumes the builder and constructs a [`ListLeaderboardsInput`](crate::input::ListLeaderboardsInput).
        pub fn build(self) -> crate::input::ListLeaderboardsInput {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::input::ListLeaderboardsInput {
            crate::input::ListLeaderboardsInput {
                next_token: self.next_token
                ,
                max_results: self.max_results
                ,
            }
        }
    }
    
    
    
    
}

