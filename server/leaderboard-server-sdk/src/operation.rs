// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

const CONTENT_TYPE_SUBMITSCOREEVENT: ::mime::Mime = ::mime::APPLICATION_JSON;
            ::pin_project_lite::pin_project! {
                /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
                /// [`SubmitScoreEventInput`](crate::input::SubmitScoreEventInput) using modelled bindings.
                pub struct SubmitScoreEventInputFuture {
                    inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::SubmitScoreEventInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
                }
            }

            impl std::future::Future for SubmitScoreEventInputFuture {
                type Output = Result<crate::input::SubmitScoreEventInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>;

                fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
                    let this = self.project();
                    this.inner.as_mut().poll(cx)
                }
            }

            impl<B> ::aws_smithy_http_server::request::FromRequest<::aws_smithy_http_server::protocol::rest_json_1::RestJson1, B> for crate::input::SubmitScoreEventInput
            where
                B: ::aws_smithy_http_server::body::HttpBody + Send,
                B: 'static,
                
                B::Data: Send,
                ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection : From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>
            {
                type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
                type Future = SubmitScoreEventInputFuture;

                fn from_request(request: ::http::Request<B>) -> Self::Future {
                    let fut = async move {
                        if !::aws_smithy_http_server::protocol::accept_header_classifier(request.headers(), &CONTENT_TYPE_SUBMITSCOREEVENT) {
                            return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
                        }
                        
                        crate::protocol_serde::shape_submit_score_event::de_submit_score_event_http_request(request)
                            .await
                            .map_err(Into::into)
                    };
                    use ::futures_util::future::TryFutureExt;
                    let fut = fut.map_err(|e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                        ::tracing::debug!(error = %e, "failed to deserialize request");
                        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e)
                    });
                    SubmitScoreEventInputFuture {
                        inner: Box::pin(fut)
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::output::SubmitScoreEventOutput {
                fn into_response(self) -> ::aws_smithy_http_server::response::Response {
                    match crate::protocol_serde::shape_submit_score_event::ser_submit_score_event_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
                        }
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::error::SubmitScoreEventError {
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_submit_score_event::ser_submit_score_event_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()));
                response
            },
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_DELETELEADERBOARD: ::mime::Mime = ::mime::APPLICATION_JSON;
            ::pin_project_lite::pin_project! {
                /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
                /// [`DeleteLeaderboardInput`](crate::input::DeleteLeaderboardInput) using modelled bindings.
                pub struct DeleteLeaderboardInputFuture {
                    inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::DeleteLeaderboardInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
                }
            }

            impl std::future::Future for DeleteLeaderboardInputFuture {
                type Output = Result<crate::input::DeleteLeaderboardInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>;

                fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
                    let this = self.project();
                    this.inner.as_mut().poll(cx)
                }
            }

            impl<B> ::aws_smithy_http_server::request::FromRequest<::aws_smithy_http_server::protocol::rest_json_1::RestJson1, B> for crate::input::DeleteLeaderboardInput
            where
                B: ::aws_smithy_http_server::body::HttpBody + Send,
                B: 'static,
                
                B::Data: Send,
                ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection : From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>
            {
                type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
                type Future = DeleteLeaderboardInputFuture;

                fn from_request(request: ::http::Request<B>) -> Self::Future {
                    let fut = async move {
                        if !::aws_smithy_http_server::protocol::accept_header_classifier(request.headers(), &CONTENT_TYPE_DELETELEADERBOARD) {
                            return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
                        }
                        
                        crate::protocol_serde::shape_delete_leaderboard::de_delete_leaderboard_http_request(request)
                            .await
                            .map_err(Into::into)
                    };
                    use ::futures_util::future::TryFutureExt;
                    let fut = fut.map_err(|e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                        ::tracing::debug!(error = %e, "failed to deserialize request");
                        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e)
                    });
                    DeleteLeaderboardInputFuture {
                        inner: Box::pin(fut)
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::output::DeleteLeaderboardOutput {
                fn into_response(self) -> ::aws_smithy_http_server::response::Response {
                    match crate::protocol_serde::shape_delete_leaderboard::ser_delete_leaderboard_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
                        }
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::error::DeleteLeaderboardError {
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_delete_leaderboard::ser_delete_leaderboard_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()));
                response
            },
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_UPDATELEADERBOARD: ::mime::Mime = ::mime::APPLICATION_JSON;
            ::pin_project_lite::pin_project! {
                /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
                /// [`UpdateLeaderboardInput`](crate::input::UpdateLeaderboardInput) using modelled bindings.
                pub struct UpdateLeaderboardInputFuture {
                    inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::UpdateLeaderboardInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
                }
            }

            impl std::future::Future for UpdateLeaderboardInputFuture {
                type Output = Result<crate::input::UpdateLeaderboardInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>;

                fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
                    let this = self.project();
                    this.inner.as_mut().poll(cx)
                }
            }

            impl<B> ::aws_smithy_http_server::request::FromRequest<::aws_smithy_http_server::protocol::rest_json_1::RestJson1, B> for crate::input::UpdateLeaderboardInput
            where
                B: ::aws_smithy_http_server::body::HttpBody + Send,
                B: 'static,
                
                B::Data: Send,
                ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection : From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>
            {
                type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
                type Future = UpdateLeaderboardInputFuture;

                fn from_request(request: ::http::Request<B>) -> Self::Future {
                    let fut = async move {
                        if !::aws_smithy_http_server::protocol::accept_header_classifier(request.headers(), &CONTENT_TYPE_UPDATELEADERBOARD) {
                            return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
                        }
                        
                        crate::protocol_serde::shape_update_leaderboard::de_update_leaderboard_http_request(request)
                            .await
                            .map_err(Into::into)
                    };
                    use ::futures_util::future::TryFutureExt;
                    let fut = fut.map_err(|e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                        ::tracing::debug!(error = %e, "failed to deserialize request");
                        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e)
                    });
                    UpdateLeaderboardInputFuture {
                        inner: Box::pin(fut)
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::output::UpdateLeaderboardOutput {
                fn into_response(self) -> ::aws_smithy_http_server::response::Response {
                    match crate::protocol_serde::shape_update_leaderboard::ser_update_leaderboard_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
                        }
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::error::UpdateLeaderboardError {
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_update_leaderboard::ser_update_leaderboard_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()));
                response
            },
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_GETLEADERBOARD: ::mime::Mime = ::mime::APPLICATION_JSON;
            ::pin_project_lite::pin_project! {
                /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
                /// [`GetLeaderboardInput`](crate::input::GetLeaderboardInput) using modelled bindings.
                pub struct GetLeaderboardInputFuture {
                    inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::GetLeaderboardInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
                }
            }

            impl std::future::Future for GetLeaderboardInputFuture {
                type Output = Result<crate::input::GetLeaderboardInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>;

                fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
                    let this = self.project();
                    this.inner.as_mut().poll(cx)
                }
            }

            impl<B> ::aws_smithy_http_server::request::FromRequest<::aws_smithy_http_server::protocol::rest_json_1::RestJson1, B> for crate::input::GetLeaderboardInput
            where
                B: ::aws_smithy_http_server::body::HttpBody + Send,
                B: 'static,
                
                B::Data: Send,
                ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection : From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>
            {
                type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
                type Future = GetLeaderboardInputFuture;

                fn from_request(request: ::http::Request<B>) -> Self::Future {
                    let fut = async move {
                        if !::aws_smithy_http_server::protocol::accept_header_classifier(request.headers(), &CONTENT_TYPE_GETLEADERBOARD) {
                            return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
                        }
                        
                        crate::protocol_serde::shape_get_leaderboard::de_get_leaderboard_http_request(request)
                            .await
                            .map_err(Into::into)
                    };
                    use ::futures_util::future::TryFutureExt;
                    let fut = fut.map_err(|e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                        ::tracing::debug!(error = %e, "failed to deserialize request");
                        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e)
                    });
                    GetLeaderboardInputFuture {
                        inner: Box::pin(fut)
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::output::GetLeaderboardOutput {
                fn into_response(self) -> ::aws_smithy_http_server::response::Response {
                    match crate::protocol_serde::shape_get_leaderboard::ser_get_leaderboard_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
                        }
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::error::GetLeaderboardError {
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_get_leaderboard::ser_get_leaderboard_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()));
                response
            },
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_CREATELEADERBOARD: ::mime::Mime = ::mime::APPLICATION_JSON;
            ::pin_project_lite::pin_project! {
                /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
                /// [`CreateLeaderboardInput`](crate::input::CreateLeaderboardInput) using modelled bindings.
                pub struct CreateLeaderboardInputFuture {
                    inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::CreateLeaderboardInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
                }
            }

            impl std::future::Future for CreateLeaderboardInputFuture {
                type Output = Result<crate::input::CreateLeaderboardInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>;

                fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
                    let this = self.project();
                    this.inner.as_mut().poll(cx)
                }
            }

            impl<B> ::aws_smithy_http_server::request::FromRequest<::aws_smithy_http_server::protocol::rest_json_1::RestJson1, B> for crate::input::CreateLeaderboardInput
            where
                B: ::aws_smithy_http_server::body::HttpBody + Send,
                B: 'static,
                
                B::Data: Send,
                ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection : From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>
            {
                type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
                type Future = CreateLeaderboardInputFuture;

                fn from_request(request: ::http::Request<B>) -> Self::Future {
                    let fut = async move {
                        if !::aws_smithy_http_server::protocol::accept_header_classifier(request.headers(), &CONTENT_TYPE_CREATELEADERBOARD) {
                            return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
                        }
                        
                        crate::protocol_serde::shape_create_leaderboard::de_create_leaderboard_http_request(request)
                            .await
                            .map_err(Into::into)
                    };
                    use ::futures_util::future::TryFutureExt;
                    let fut = fut.map_err(|e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                        ::tracing::debug!(error = %e, "failed to deserialize request");
                        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e)
                    });
                    CreateLeaderboardInputFuture {
                        inner: Box::pin(fut)
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::output::CreateLeaderboardOutput {
                fn into_response(self) -> ::aws_smithy_http_server::response::Response {
                    match crate::protocol_serde::shape_create_leaderboard::ser_create_leaderboard_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
                        }
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::error::CreateLeaderboardError {
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_create_leaderboard::ser_create_leaderboard_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()));
                response
            },
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_LISTLEADERBOARDS: ::mime::Mime = ::mime::APPLICATION_JSON;
            ::pin_project_lite::pin_project! {
                /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
                /// [`ListLeaderboardsInput`](crate::input::ListLeaderboardsInput) using modelled bindings.
                pub struct ListLeaderboardsInputFuture {
                    inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::ListLeaderboardsInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
                }
            }

            impl std::future::Future for ListLeaderboardsInputFuture {
                type Output = Result<crate::input::ListLeaderboardsInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>;

                fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
                    let this = self.project();
                    this.inner.as_mut().poll(cx)
                }
            }

            impl<B> ::aws_smithy_http_server::request::FromRequest<::aws_smithy_http_server::protocol::rest_json_1::RestJson1, B> for crate::input::ListLeaderboardsInput
            where
                B: ::aws_smithy_http_server::body::HttpBody + Send,
                B: 'static,
                
                B::Data: Send,
                ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection : From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>
            {
                type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
                type Future = ListLeaderboardsInputFuture;

                fn from_request(request: ::http::Request<B>) -> Self::Future {
                    let fut = async move {
                        if !::aws_smithy_http_server::protocol::accept_header_classifier(request.headers(), &CONTENT_TYPE_LISTLEADERBOARDS) {
                            return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
                        }
                        
                        crate::protocol_serde::shape_list_leaderboards::de_list_leaderboards_http_request(request)
                            .await
                            .map_err(Into::into)
                    };
                    use ::futures_util::future::TryFutureExt;
                    let fut = fut.map_err(|e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                        ::tracing::debug!(error = %e, "failed to deserialize request");
                        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e)
                    });
                    ListLeaderboardsInputFuture {
                        inner: Box::pin(fut)
                    }
                }
            }
impl ::aws_smithy_http_server::response::IntoResponse<::aws_smithy_http_server::protocol::rest_json_1::RestJson1> for crate::output::ListLeaderboardsOutput {
                fn into_response(self) -> ::aws_smithy_http_server::response::Response {
                    match crate::protocol_serde::shape_list_leaderboards::ser_list_leaderboards_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
                        }
                    }
                }
            }

