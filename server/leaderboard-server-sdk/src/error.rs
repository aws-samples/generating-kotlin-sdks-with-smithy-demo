// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `SubmitScoreEvent` operation.
/// Each variant represents an error that can occur for the `SubmitScoreEvent` operation.
#[derive(::std::fmt::Debug)]
pub enum SubmitScoreEventError {
    #[allow(missing_docs)] // documentation missing in model
    NotFoundError(crate::error::NotFoundError),
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
}
impl ::std::fmt::Display for SubmitScoreEventError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            SubmitScoreEventError::NotFoundError(_inner) =>
            _inner.fmt(f)
            ,
            SubmitScoreEventError::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
        }
    }
}
impl SubmitScoreEventError {
    /// Returns `true` if the error kind is `SubmitScoreEventError::NotFoundError`.
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self, SubmitScoreEventError::NotFoundError(_))
    }
    /// Returns `true` if the error kind is `SubmitScoreEventError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, SubmitScoreEventError::ValidationException(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            SubmitScoreEventError::NotFoundError(_inner) =>
            _inner.name()
            ,
            SubmitScoreEventError::ValidationException(_inner) =>
            _inner.name()
            ,
        }
    }
}
impl ::std::error::Error for SubmitScoreEventError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            SubmitScoreEventError::NotFoundError(_inner) =>
            Some(_inner)
            ,
            SubmitScoreEventError::ValidationException(_inner) =>
            Some(_inner)
            ,
        }
    }
}
impl ::std::convert::From<crate::error::NotFoundError> for crate::error::SubmitScoreEventError {
    fn from(variant: crate::error::NotFoundError) -> crate::error::SubmitScoreEventError {
        Self::NotFoundError(variant)
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::SubmitScoreEventError {
    fn from(variant: crate::error::ValidationException) -> crate::error::SubmitScoreEventError {
        Self::ValidationException(variant)
    }
}

/// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct ValidationException  {
    /// A summary of the validation failure.
    pub message: ::std::string::String,
    /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
    pub field_list: ::std::option::Option<::std::vec::Vec::<crate::model::ValidationExceptionField>>,
}
impl  ValidationException  {
    /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
    pub fn field_list(&self) -> ::std::option::Option<& [crate::model::ValidationExceptionField]> {
        self.field_list.as_deref()
    }
}
impl ValidationException {
    /// Returns the error message.
                        pub fn message(&self) -> &str { &self.message }
    #[doc(hidden)]
                        /// Returns the error name.
                        pub fn name(&self) -> &'static str {
                            "ValidationException"
                        }
}
impl ::std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ValidationException")?;
         {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ValidationException {}
impl  ValidationException  {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder  {
        crate::error::validation_exception::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct NotFoundError  {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::option::Option<::std::string::String>,
}
impl NotFoundError {
    /// Returns the error message.
                        pub fn message(&self) -> ::std::option::Option<& str> { self.message.as_deref() }
    #[doc(hidden)]
                        /// Returns the error name.
                        pub fn name(&self) -> &'static str {
                            "NotFoundError"
                        }
}
impl ::std::fmt::Display for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "NotFoundError")?;
        if let ::std::option::Option::Some(inner_1) = &self.message {
             {
                ::std::write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for NotFoundError {}
impl  NotFoundError  {
    /// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError).
    pub fn builder() -> crate::error::not_found_error::Builder  {
        crate::error::not_found_error::Builder::default()
    }
}

/// Error type for the `DeleteLeaderboard` operation.
/// Each variant represents an error that can occur for the `DeleteLeaderboard` operation.
#[derive(::std::fmt::Debug)]
pub enum DeleteLeaderboardError {
    #[allow(missing_docs)] // documentation missing in model
    NotFoundError(crate::error::NotFoundError),
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
}
impl ::std::fmt::Display for DeleteLeaderboardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            DeleteLeaderboardError::NotFoundError(_inner) =>
            _inner.fmt(f)
            ,
            DeleteLeaderboardError::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
        }
    }
}
impl DeleteLeaderboardError {
    /// Returns `true` if the error kind is `DeleteLeaderboardError::NotFoundError`.
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self, DeleteLeaderboardError::NotFoundError(_))
    }
    /// Returns `true` if the error kind is `DeleteLeaderboardError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, DeleteLeaderboardError::ValidationException(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            DeleteLeaderboardError::NotFoundError(_inner) =>
            _inner.name()
            ,
            DeleteLeaderboardError::ValidationException(_inner) =>
            _inner.name()
            ,
        }
    }
}
impl ::std::error::Error for DeleteLeaderboardError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            DeleteLeaderboardError::NotFoundError(_inner) =>
            Some(_inner)
            ,
            DeleteLeaderboardError::ValidationException(_inner) =>
            Some(_inner)
            ,
        }
    }
}
impl ::std::convert::From<crate::error::NotFoundError> for crate::error::DeleteLeaderboardError {
    fn from(variant: crate::error::NotFoundError) -> crate::error::DeleteLeaderboardError {
        Self::NotFoundError(variant)
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::DeleteLeaderboardError {
    fn from(variant: crate::error::ValidationException) -> crate::error::DeleteLeaderboardError {
        Self::ValidationException(variant)
    }
}

/// Error type for the `UpdateLeaderboard` operation.
/// Each variant represents an error that can occur for the `UpdateLeaderboard` operation.
#[derive(::std::fmt::Debug)]
pub enum UpdateLeaderboardError {
    #[allow(missing_docs)] // documentation missing in model
    NotFoundError(crate::error::NotFoundError),
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
}
impl ::std::fmt::Display for UpdateLeaderboardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            UpdateLeaderboardError::NotFoundError(_inner) =>
            _inner.fmt(f)
            ,
            UpdateLeaderboardError::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
        }
    }
}
impl UpdateLeaderboardError {
    /// Returns `true` if the error kind is `UpdateLeaderboardError::NotFoundError`.
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self, UpdateLeaderboardError::NotFoundError(_))
    }
    /// Returns `true` if the error kind is `UpdateLeaderboardError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, UpdateLeaderboardError::ValidationException(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            UpdateLeaderboardError::NotFoundError(_inner) =>
            _inner.name()
            ,
            UpdateLeaderboardError::ValidationException(_inner) =>
            _inner.name()
            ,
        }
    }
}
impl ::std::error::Error for UpdateLeaderboardError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            UpdateLeaderboardError::NotFoundError(_inner) =>
            Some(_inner)
            ,
            UpdateLeaderboardError::ValidationException(_inner) =>
            Some(_inner)
            ,
        }
    }
}
impl ::std::convert::From<crate::error::NotFoundError> for crate::error::UpdateLeaderboardError {
    fn from(variant: crate::error::NotFoundError) -> crate::error::UpdateLeaderboardError {
        Self::NotFoundError(variant)
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::UpdateLeaderboardError {
    fn from(variant: crate::error::ValidationException) -> crate::error::UpdateLeaderboardError {
        Self::ValidationException(variant)
    }
}

/// Error type for the `GetLeaderboard` operation.
/// Each variant represents an error that can occur for the `GetLeaderboard` operation.
#[derive(::std::fmt::Debug)]
pub enum GetLeaderboardError {
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
    #[allow(missing_docs)] // documentation missing in model
    NotFoundError(crate::error::NotFoundError),
}
impl ::std::fmt::Display for GetLeaderboardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            GetLeaderboardError::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetLeaderboardError::NotFoundError(_inner) =>
            _inner.fmt(f)
            ,
        }
    }
}
impl GetLeaderboardError {
    /// Returns `true` if the error kind is `GetLeaderboardError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, GetLeaderboardError::ValidationException(_))
    }
    /// Returns `true` if the error kind is `GetLeaderboardError::NotFoundError`.
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self, GetLeaderboardError::NotFoundError(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            GetLeaderboardError::ValidationException(_inner) =>
            _inner.name()
            ,
            GetLeaderboardError::NotFoundError(_inner) =>
            _inner.name()
            ,
        }
    }
}
impl ::std::error::Error for GetLeaderboardError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            GetLeaderboardError::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetLeaderboardError::NotFoundError(_inner) =>
            Some(_inner)
            ,
        }
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::GetLeaderboardError {
    fn from(variant: crate::error::ValidationException) -> crate::error::GetLeaderboardError {
        Self::ValidationException(variant)
    }
}
impl ::std::convert::From<crate::error::NotFoundError> for crate::error::GetLeaderboardError {
    fn from(variant: crate::error::NotFoundError) -> crate::error::GetLeaderboardError {
        Self::NotFoundError(variant)
    }
}

/// Error type for the `CreateLeaderboard` operation.
/// Each variant represents an error that can occur for the `CreateLeaderboard` operation.
#[derive(::std::fmt::Debug)]
pub enum CreateLeaderboardError {
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
}
impl ::std::fmt::Display for CreateLeaderboardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            CreateLeaderboardError::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
        }
    }
}
impl CreateLeaderboardError {
    /// Returns `true` if the error kind is `CreateLeaderboardError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, CreateLeaderboardError::ValidationException(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            CreateLeaderboardError::ValidationException(_inner) =>
            _inner.name()
            ,
        }
    }
}
impl ::std::error::Error for CreateLeaderboardError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            CreateLeaderboardError::ValidationException(_inner) =>
            Some(_inner)
            ,
        }
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::CreateLeaderboardError {
    fn from(variant: crate::error::ValidationException) -> crate::error::CreateLeaderboardError {
        Self::ValidationException(variant)
    }
}

/// See [`ValidationException`](crate::error::ValidationException).
/// 
pub mod validation_exception {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    
                #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `ValidationException`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(f, "`message` was not provided but it is required when building `ValidationException`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl  ::std::convert::TryFrom<Builder > for crate::error::ValidationException {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
        pub(crate) field_list: ::std::option::Option<::std::vec::Vec::<crate::model::ValidationExceptionField>>,
    }
    impl  Builder  {
        /// A summary of the validation failure.
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message =
                Some(
                    input
                )
            ; self
        }
        /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
        pub fn field_list(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::model::ValidationExceptionField>>) -> Self {
            self.field_list =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        /// 
        /// The builder fails to construct a [`ValidationException`](crate::error::ValidationException) if a [`ConstraintViolation`] occurs.
        /// 
        pub fn build(self) -> Result<crate::error::ValidationException , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::error::ValidationException , ConstraintViolation> {
            Ok(
                crate::error::ValidationException {
                    message: self.message
                        .ok_or(ConstraintViolation::MissingMessage)?
                    ,
                    field_list: self.field_list
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`NotFoundError`](crate::error::NotFoundError).
/// 
pub mod not_found_error {
    
    impl ::std::convert::From<Builder > for crate::error::NotFoundError  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`NotFoundError`](crate::error::NotFoundError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.message =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError).
        pub fn build(self) -> crate::error::NotFoundError {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::error::NotFoundError {
            crate::error::NotFoundError {
                message: self.message
                ,
            }
        }
    }
    
    
    
    
}

